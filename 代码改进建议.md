# 🔧 代码改进建议 - 基于防爬虫规则

> **目的：** 在后续开发中强化对Apple API限制的保护  
> **优先级：** 高（必须实现）

---

## 🎯 必须实现的改进

### 1. 随机化User-Agent ⭐⭐⭐⭐⭐

**当前问题：**

`config.json` 和 `apple_store_monitor.py` 都使用固定的User-Agent，容易被识别为机器人。

```python
# 当前代码 - apple_store_monitor.py: 64-65行
headers = {
    'User-Agent': self.config.get('user_agent', 
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'),
```

**问题：**
- 🔴 固定User-Agent
- 🔴 容易被识别为机器人
- 🔴 增加被限制的风险

**改进方案：**

在 `apple_store_monitor.py` 顶部添加：

```python
import random

# User-Agent池
USER_AGENTS = [
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/120.0.0.0',
]
```

修改 `_create_session` 方法（第59-85行）：

```python
def _create_session(self) -> requests.Session:
    """创建HTTP会话"""
    session = requests.Session()
    
    headers = {
        'User-Agent': random.choice(USER_AGENTS),  # ✅ 随机选择
        'Accept': 'application/json',
        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'Referer': 'https://www.apple.com.cn/shop/buy-iphone',
        'Origin': 'https://www.apple.com.cn',
        'Connection': 'keep-alive',
        'Cache-Control': 'no-cache',
    }
    session.headers.update(headers)
    
    # ... 其他代码保持不变
    return session
```

**另外：** 在每次请求前也可以更换User-Agent：

```python
def check_product_availability(self, part_number: str, store_number: str = None) -> Dict:
    """检查商品库存"""
    try:
        # ✅ 每次请求前更换User-Agent
        self.session.headers['User-Agent'] = random.choice(USER_AGENTS)
        
        # ... 原有代码
```

---

### 2. 随机延迟间隔 ⭐⭐⭐⭐⭐

**当前问题：**

```python
# apple_store_monitor.py: 305行
self._interruptible_sleep(1)  # 固定1秒，太规律
```

**问题：**
- 🔴 固定间隔
- 🔴 极其规律
- 🔴 明显的机器人特征

**改进方案：**

在 `AppleStoreMonitor` 类中添加新方法：

```python
def _smart_delay(self, base_delay: float, variance: float = 0.2):
    """
    智能延迟：添加随机波动，模拟人类行为
    
    Args:
        base_delay: 基础延迟（秒）
        variance: 波动幅度（0.2 = ±20%）
    """
    import random
    
    min_delay = base_delay * (1 - variance)
    max_delay = base_delay * (1 + variance)
    delay = random.uniform(min_delay, max_delay)
    
    logger.debug(f"延迟 {delay:.2f} 秒")
    self._interruptible_sleep(delay)
```

**替换所有固定延迟：**

```python
# 原来：
self._interruptible_sleep(1)

# 改为：
self._smart_delay(1, 0.2)  # 0.8-1.2秒随机

# 原来：
self._interruptible_sleep(3)

# 改为：
self._smart_delay(3, 0.15)  # 2.55-3.45秒随机

# 原来：
self._interruptible_sleep(10)

# 改为：
self._smart_delay(10, 0.1)  # 9-11秒随机
```

**进一步优化：使用正态分布**

```python
def _human_like_delay(self, mean: float, std: float = 0.3):
    """
    更接近人类的延迟模式（正态分布）
    
    Args:
        mean: 平均延迟
        std: 标准差（相对值）
    """
    import random
    
    # 正态分布
    delay = random.gauss(mean, mean * std)
    
    # 限制在合理范围内
    min_delay = mean * 0.5
    max_delay = mean * 1.5
    delay = max(min_delay, min(max_delay, delay))
    
    self._interruptible_sleep(delay)
```

---

### 3. 会话管理和轮换 ⭐⭐⭐⭐

**添加请求计数器：**

在 `__init__` 方法中添加：

```python
def __init__(self, config: dict, stop_event=None):
    # ... 现有代码
    self.request_count = 0  # ✅ 添加计数器
    self.session_start_time = datetime.now()  # ✅ 会话开始时间
```

**定期重建Session：**

在 `check_product_availability` 方法中：

```python
def check_product_availability(self, part_number: str, store_number: str = None) -> Dict:
    try:
        # ✅ 每100次请求重建Session
        self.request_count += 1
        if self.request_count % 100 == 0:
            logger.info(f"已发送{self.request_count}次请求，重建Session...")
            self.session.close()
            self.session = self._create_session()
        
        # ✅ 每小时重置计数器
        if (datetime.now() - self.session_start_time).total_seconds() > 3600:
            logger.info("已运行1小时，重置计数器...")
            self.request_count = 0
            self.session_start_time = datetime.now()
        
        # ... 原有代码
```

---

### 4. 增强的错误保护 ⭐⭐⭐⭐

**当前代码：**

```python
# apple_store_monitor.py: 284-294行
elif 'HTTP 541' in str(result.get('error', '')):
    error_count += 1
    
    if error_count >= 3:
        logger.warning(f"⚠️  连续{error_count}次遇到API限制！")
        skip_remaining = True
```

**改进方案：指数退避**

```python
def _exponential_backoff(self, error_count: int) -> float:
    """
    指数退避策略
    
    Args:
        error_count: 连续错误次数
        
    Returns:
        等待时间（秒）
    """
    backoff_times = {
        1: 10,   # 第1次: 10秒
        2: 30,   # 第2次: 30秒
        3: 60,   # 第3次: 60秒
        4: 120,  # 第4次: 120秒
    }
    
    return backoff_times.get(error_count, 300)  # 默认5分钟

# 使用：
elif 'HTTP 541' in str(result.get('error', '')):
    error_count += 1
    backoff_time = self._exponential_backoff(error_count)
    
    logger.warning(f"⚠️  HTTP 541错误 (第{error_count}次)")
    logger.warning(f"等待{backoff_time}秒后继续...")
    
    self._interruptible_sleep(backoff_time)
    
    if error_count >= 3:
        logger.error(f"连续{error_count}次触发限制，跳过剩余门店")
        skip_remaining = True
```

---

### 5. 请求频率监控 ⭐⭐⭐

**添加实时频率监控：**

在 `__init__` 方法中：

```python
def __init__(self, config: dict, stop_event=None):
    # ... 现有代码
    self.request_times = []  # ✅ 记录请求时间
```

**添加监控方法：**

```python
def _record_request(self):
    """记录请求时间"""
    now = time.time()
    self.request_times.append(now)
    
    # 只保留最近60秒的记录
    cutoff = now - 60
    self.request_times = [t for t in self.request_times if t > cutoff]
    
    # 计算当前频率
    current_rate = len(self.request_times)
    
    # 警告
    if current_rate > 10:
        logger.warning(f"⚠️  当前频率: {current_rate}次/分钟 - 超过安全阈值！")
    elif current_rate > 8:
        logger.info(f"ℹ️  当前频率: {current_rate}次/分钟 - 接近阈值")
    
    return current_rate

# 在每次请求前调用：
def check_product_availability(self, part_number: str, store_number: str = None):
    try:
        # ✅ 记录并检查频率
        rate = self._record_request()
        
        # 如果频率过高，主动延迟
        if rate > 12:
            logger.warning("频率过高，额外延迟5秒...")
            self._interruptible_sleep(5)
        
        # ... 原有代码
```

---

### 6. 配置验证 ⭐⭐⭐

**在启动时验证配置安全性：**

```python
def _validate_config(self):
    """验证配置是否安全"""
    product_count = len(self.config.get('target_products', []))
    
    if self.config.get('all_stores', False):
        store_count = len(self.stores)
    else:
        store_count = len(self.config.get('target_stores', []))
    
    check_interval = self.config.get('check_interval', 30)
    
    # 计算频率
    one_round = store_count * 1  # 假设门店间1秒
    total_cycle = one_round + check_interval
    rate = (product_count * store_count) / total_cycle * 60
    
    logger.info(f"配置验证:")
    logger.info(f"  产品数: {product_count}")
    logger.info(f"  门店数: {store_count}")
    logger.info(f"  检查间隔: {check_interval}秒")
    logger.info(f"  预计频率: {rate:.2f}次/分钟")
    
    if rate > 15:
        logger.error(f"⚠️  配置不安全！频率{rate:.2f}次/分钟 > 15次/分钟")
        logger.error(f"建议: 减少门店数或增加check_interval")
        raise ValueError("配置不安全，频率过高")
    elif rate > 10:
        logger.warning(f"⚠️  配置有风险！频率{rate:.2f}次/分钟 > 10次/分钟")
        logger.warning(f"建议: 减少门店数或增加check_interval")
        
        # 询问用户
        choice = input("是否继续？(y/n): ").strip().lower()
        if choice != 'y':
            raise ValueError("用户取消")
    else:
        logger.info(f"✅ 配置安全")
    
    return rate

# 在__init__中调用：
def __init__(self, config: dict, stop_event=None):
    # ... 现有代码
    self._validate_config()  # ✅ 验证配置
```

---

## 📝 代码文件修改清单

### apple_store_monitor.py

**需要添加的代码：**

```python
# 1. 顶部导入和常量
import random
from datetime import datetime

USER_AGENTS = [
    # ... User-Agent池
]

# 2. 修改__init__方法
def __init__(self, config: dict, stop_event=None):
    # 添加：
    self.request_count = 0
    self.session_start_time = datetime.now()
    self.request_times = []
    
    # 在最后添加：
    self._validate_config()

# 3. 添加新方法
def _smart_delay(self, base_delay: float, variance: float = 0.2):
    # ... 实现

def _exponential_backoff(self, error_count: int) -> float:
    # ... 实现

def _record_request(self):
    # ... 实现

def _validate_config(self):
    # ... 实现

# 4. 修改_create_session
def _create_session(self):
    headers = {
        'User-Agent': random.choice(USER_AGENTS),  # 修改这里
        # ...
    }

# 5. 修改check_product_availability
def check_product_availability(self, part_number: str, store_number: str = None):
    try:
        # 添加：
        self.request_count += 1
        rate = self._record_request()
        
        # 添加：每100次重建Session
        if self.request_count % 100 == 0:
            # ...
        
        # 修改User-Agent
        self.session.headers['User-Agent'] = random.choice(USER_AGENTS)
        
        # ... 原有代码

# 6. 替换所有_interruptible_sleep为_smart_delay
# 查找：self._interruptible_sleep(1)
# 替换为：self._smart_delay(1, 0.2)
```

---

### main.py

**添加配置警告：**

```python
def main():
    # 在加载配置后添加：
    config = load_config()
    
    # ✅ 添加配置检查
    from rate_calculator import calculate_request_rate
    
    product_count = len(config['target_products'])
    store_count = len(config.get('target_stores', []))
    if config.get('all_stores', False):
        store_count = 48  # 或从stores文件读取
    
    result = calculate_request_rate(
        product_count,
        store_count,
        1,
        config.get('check_interval', 30)
    )
    
    if not result['safe']:
        print(f"\n{Fore.RED}{'='*70}")
        print(f"⚠️  警告：当前配置不安全！")
        print(f"{'='*70}{Style.RESET_ALL}")
        print(f"\n实际频率：{result['rate_per_minute']:.2f}次/分钟")
        print(f"安全标准：≤ 10次/分钟")
        print(f"\n建议：")
        print(f"  1. 使用 python3 rate_calculator.py 查看详细分析")
        print(f"  2. 使用 cp config_safe.json config.json 切换到安全配置")
        print(f"  3. 或手动修改配置")
        print(f"\n{Fore.RED}{'='*70}{Style.RESET_ALL}\n")
        
        choice = input("是否继续？(y/n): ").strip().lower()
        if choice != 'y':
            print("已退出")
            return
    
    # ... 继续原有代码
```

---

## 🎯 实现优先级

### 立即实现（P0）

1. **随机化User-Agent** - 最容易实现，效果显著
2. **随机延迟间隔** - 关键保护措施
3. **配置验证** - 防止配置错误

### 尽快实现（P1）

4. **指数退避重试** - 增强容错性
5. **请求频率监控** - 实时监控和预警

### 可选实现（P2）

6. **会话管理** - 长期运行的优化

---

## 🧪 测试建议

### 1. 单元测试

```python
# test_monitor.py
def test_smart_delay():
    """测试智能延迟"""
    monitor = AppleStoreMonitor(config, None)
    
    delays = []
    for _ in range(10):
        start = time.time()
        monitor._smart_delay(1, 0.2)
        delays.append(time.time() - start)
    
    # 应该有变化
    assert len(set([round(d, 1) for d in delays])) > 1
    
    # 在合理范围内
    assert all(0.8 <= d <= 1.2 for d in delays)

def test_request_rate_monitoring():
    """测试频率监控"""
    monitor = AppleStoreMonitor(config, None)
    
    for _ in range(15):
        rate = monitor._record_request()
    
    # 应该记录15次
    assert rate == 15
```

### 2. 集成测试

```bash
# 测试修改后的配置
python3 -c "
from apple_store_monitor import AppleStoreMonitor
from rate_calculator import calculate_request_rate

config = {...}
monitor = AppleStoreMonitor(config, None)
# 测试10次请求
for i in range(10):
    monitor.check_product_availability('MXUA3CH/A', 'R359')
"
```

---

## 📊 预期效果

实现这些改进后：

- ✅ **降低被识别为机器人的风险**
- ✅ **减少HTTP 541错误的频率**
- ✅ **提高长时间运行的稳定性**
- ✅ **更好的错误恢复能力**
- ✅ **实时监控和预警**

---

## 🔄 渐进式实施

### 第一阶段（1天）

- 实现随机User-Agent
- 实现随机延迟
- 添加配置验证

### 第二阶段（1-2天）

- 实现指数退避
- 实现频率监控
- 添加测试

### 第三阶段（按需）

- 会话管理
- 高级优化
- 性能调优

---

**文档生成时间：** 2025-10-06  
**目的：** 指导后续代码改进  
**重要性：** ⭐⭐⭐⭐⭐


