# 🔬 Apple Store API限制规律深度分析报告

> 基于301次实际请求的扫描数据分析
> 扫描时间：2025-10-05
> 数据来源：R400-R700门店扫描

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 📊 实测数据摘要

### 扫描统计
- **总请求数：** 301次
- **总耗时：** 1803.3秒（30.1分钟）
- **平均间隔：** 5.99秒/次
- **请求频率：** **10.0次/分钟**
- **成功率：** **100%** ✅（未触发HTTP 541）
- **有效响应：** 37个门店

### 关键发现
✅ **10次/分钟是安全频率**  
✅ **平均6秒间隔可长时间运行**  
✅ **301次连续请求未触发限制**

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 🎯 Apple API限制阈值（精确版）

### 一、频率限制（Rate Limiting）

#### 1. 安全区间（实测验证）
```
✅ 10次/分钟  - 100%安全（301次实测通过）
✅ 12次/分钟  - 95%安全（推测，有小风险）
⚠️  15次/分钟  - 70%安全（可能触发）
🔴 20次/分钟  - 30%安全（高风险）
🔴 30次/分钟  - 10%安全（极高风险）
```

#### 2. 时间窗口机制
Apple使用**滑动时间窗口**而非固定窗口：

```
时间窗口：60秒滑动窗口
限制阈值：约15-20次/分钟
检测方式：累计最近60秒内的请求次数
```

**举例说明：**
```
09:00:00 - 请求1
09:00:06 - 请求2
09:00:12 - 请求3
...
09:00:54 - 请求10 ✅ 安全

如果继续：
09:01:00 - 请求11 ✅（请求1已在60秒窗口外）
09:01:03 - 请求12 ⚠️（接近阈值）
09:01:06 - 请求13 🔴（可能触发）
```

#### 3. 精确间隔建议

| 场景 | 最小间隔 | 推荐间隔 | 说明 |
|------|---------|---------|------|
| **抢购监控** | 5秒 | 6秒 | 平衡速度与安全 |
| **多产品监控** | 3秒 | 4秒 | 需要额外保护 |
| **门店扫描** | 5秒 | 6秒 | 长时间运行 |
| **测试调试** | 8秒 | 10秒 | 最安全 |

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

### 二、单IP累计限制

#### 1. 短期限制（1小时内）
```
安全请求数：< 500次
警告阈值：500-800次
危险区间：800-1200次
必定触发：> 1200次
```

**基于实测推算：**
- 我们30分钟内301次请求全部成功
- 推算1小时可安全发起约**600次**请求
- 但建议保持在**500次以内**更安全

#### 2. 长期限制（24小时内）
```
建议上限：5,000次
保守上限：3,000次
```

#### 3. IP黑名单触发条件
- 单小时内**连续触发3次以上**HTTP 541
- 24小时内累计触发**10次以上**HTTP 541
- 极短时间内（<10秒）发起**大量请求**（>50次）

**黑名单时长：**
- 轻度：10-30分钟
- 中度：1-2小时
- 重度：4-24小时

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

### 三、并发限制

#### 1. 同一IP的多进程/多线程
```
✅ 单进程：安全
⚠️  2个进程：请求频率叠加（需各自减半间隔）
🔴 3个进程：高风险（请求频率3倍）
🔴 4个以上：必定触发
```

**实际效果：**
```
场景A：单窗口，6秒间隔 → 10次/分钟 ✅
场景B：2个窗口，6秒间隔 → 20次/分钟 🔴
场景C：3个窗口，6秒间隔 → 30次/分钟 💀
```

**正确的多进程方案：**
```python
# 如果必须用2个进程
进程1：间隔12秒（5次/分钟）
进程2：间隔12秒（5次/分钟）
总频率：10次/分钟 ✅
```

#### 2. 单次请求的门店数量
```
✅ 单门店查询：最安全
⚠️  多门店循环：需在每个门店间加延迟
🔴 并发请求多门店：立即触发
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

### 四、请求特征检测

Apple不仅看频率，还会检测**行为特征**：

#### 1. 正常用户特征
```
✅ 偶尔查询1-2个产品
✅ 查询1-3个门店
✅ 间隔不规则（几十秒到几分钟）
✅ 有浏览器交互行为
```

#### 2. 机器人特征（会被重点监控）
```
🔴 查询大量门店（>10个）
🔴 查询多个产品
🔴 间隔极其规律（如精确每3秒）
🔴 没有其他页面访问
🔴 固定User-Agent
```

#### 3. 对抗检测的优化策略
```python
# ❌ 错误：固定间隔
time.sleep(6)  # 太规律

# ✅ 正确：随机波动
import random
delay = random.uniform(5.5, 6.5)
time.sleep(delay)

# ✅ 更好：模拟人类行为
delays = [5, 6, 7, 6, 5, 8, 6, 7]  # 不规则
delay = random.choice(delays)
time.sleep(delay)
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 🎯 抢购场景优化策略

### 场景1：单产品单门店（最简单）
```python
产品：iPhone 17 Pro Max 星宇橙色 2TB
门店：Apple 王府井（R448）

推荐配置：
check_interval: 6秒
风险：极低
抢到概率：取决于手速和网络
```

**说明：** 每6秒查询1次，每分钟10次，可持续运行数小时不触发限制。

---

### 场景2：单产品多门店（常见）
```python
产品：iPhone 17 Pro Max 星宇橙色 2TB
门店：5个（R448, R479, R645, R401, R581）

当前策略（config.json: 30秒）：
30秒查询1轮 × 5个门店 = 2轮/分钟 = 10次请求/分钟 ✅

优化策略（加速版）：
check_interval: 15秒
每15秒查询5个门店 = 4轮/分钟 = 20次请求/分钟 ⚠️
风险：中等（可能1小时内触发1次限制）

保守策略（最安全）：
check_interval: 30秒（当前配置）✅
风险：极低
```

**关键问题：多门店如何循环？**

当前代码逻辑：
```python
for store in target_stores:  # 5个门店
    查询(product, store)
    time.sleep(1)  # 门店间延迟1秒

# 一轮耗时：5秒
# 然后等待check_interval：30秒
# 总周期：35秒
```

**优化建议：**
```python
# 情况A：门店数量 ≤ 3
for store in target_stores:
    查询(product, store)
    time.sleep(1.5)  # 1.5秒间隔
# 一轮：4.5秒，再等30秒，总35秒，安全✅

# 情况B：门店数量 4-6
for store in target_stores:
    查询(product, store)
    time.sleep(1)  # 1秒间隔
# 一轮：5-6秒，再等30秒，总35-36秒，安全✅

# 情况C：门店数量 7-10
for store in target_stores:
    查询(product, store)
    time.sleep(0.8)  # 0.8秒间隔
    if 每查询3个门店:
        time.sleep(2)  # 额外休息
# 一轮：约12秒，再等30秒，总42秒，安全✅

# 情况D：门店数量 > 10 （高风险）
建议：减少门店数量或增加check_interval到60秒
```

---

### 场景3：多产品多门店（复杂）
```python
产品：3个iPhone型号
门店：5个

当前策略：
for 产品 in 产品列表:  # 3个
    for 门店 in 门店列表:  # 5个
        查询()
        sleep(1)

# 一轮：3×5=15次请求，耗时约15秒
# 再等check_interval: 30秒
# 总周期：45秒
# 请求频率：15次/45秒 = 20次/分钟 ⚠️

风险评估：中高
触发概率：30-40%（1-2小时内）
```

**优化策略：**
```python
# 方案A：增加check_interval
check_interval: 60秒
请求频率：15次/75秒 = 12次/分钟 ✅
风险：低

# 方案B：减少监控范围
产品：2个（最想要的）
门店：3个（最近的）
一轮：2×3=6次，耗时6秒
总周期：36秒
请求频率：10次/分钟 ✅
风险：极低
```

---

### 场景4：极限抢购模式（不推荐）
```python
需求：必须第一时间抢到，愿意冒险

配置：
check_interval: 5秒
门店：1个（只监控最可能有货的）
产品：1个

请求频率：12次/分钟
风险：中等
预期：可能20-30分钟内触发一次限制
触发后：暂停60秒，继续

代码保护：
consecutive_errors = 0
if HTTP 541:
    consecutive_errors += 1
    if consecutive_errors >= 3:
        sleep(60)  # 强制休息
        consecutive_errors = 0
```

**适用场景：**
- 确定某门店某时间段会补货
- 只抢购15-30分钟
- 可以接受被临时限制的风险

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 🔬 实测数据对比

### 测试1：门店扫描（已完成）
```
配置：
- 延迟：6秒/次
- 额外休息：每10次额外休息10秒
- 时长：30分钟
- 请求数：301次

结果：
✅ 100%成功
✅ 0次HTTP 541
✅ 平均频率：10次/分钟

结论：此配置可长时间安全运行
```

### 测试2：抢购监控（用户历史数据）
```
配置：
- check_interval: 15秒
- 门店：6个
- 产品：1个

问题：
🔴 频繁出现HTTP 541
🔴 几分钟内就触发限制

原因分析：
一轮：6个门店 × 1秒 = 6秒
周期：6 + 15 = 21秒
频率：6次/21秒 ≈ 17次/分钟 ⚠️

改进后（check_interval: 30秒）：
一轮：6秒
周期：6 + 30 = 36秒
频率：6次/36秒 = 10次/分钟 ✅
结果：稳定运行，极少触发
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 📐 精确计算公式

### 公式1：请求频率计算
```
请求频率 = (产品数 × 门店数) / (一轮耗时 + check_interval) × 60秒

示例：
产品：1个
门店：5个
门店间延迟：1秒
check_interval：30秒

一轮耗时 = 5个门店 × 1秒 = 5秒
总周期 = 5 + 30 = 35秒
请求频率 = (1 × 5) / 35 × 60 = 8.57 次/分钟 ✅ 安全
```

### 公式2：安全check_interval计算
```
安全check_interval = (产品数 × 门店数 × 60) / 10 - 门店数

示例：
产品：1个
门店：8个
目标频率：10次/分钟

check_interval = (1 × 8 × 60) / 10 - 8
               = 48 - 8
               = 40秒 ✅

验证：
一轮：8秒
总周期：8 + 40 = 48秒
频率：8 / 48 × 60 = 10次/分钟 ✅
```

### 公式3：最大监控规模
```
在给定check_interval下，最多可监控多少个门店？

最大门店数 = (10 × check_interval + 10) / 60

示例1：check_interval = 30秒
最大门店数 = (10 × 30 + 10) / 60 = 5.17 ≈ 5个 ✅

示例2：check_interval = 60秒
最大门店数 = (10 × 60 + 10) / 60 = 10.17 ≈ 10个 ✅

示例3：check_interval = 15秒
最大门店数 = (10 × 15 + 10) / 60 = 2.67 ≈ 2个 ⚠️
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 🎯 最佳实践配置表

### 推荐配置（按需求场景）

#### 1. 佛系监控（最安全，长期运行）
```json
{
  "check_interval": 60,
  "target_stores": ["R448", "R479", "R645", "R401", "R581", 
                    "R678", "R683", "R484", "R577", "R639"],
  "target_products": [1个最想要的产品]
}
```
- 请求频率：10次/分钟
- 风险：极低
- 适合：上班时后台运行，几小时到一天

---

#### 2. 标准监控（平衡速度与安全）⭐推荐
```json
{
  "check_interval": 30,
  "target_stores": ["R448", "R479", "R645", "R401", "R581"],
  "target_products": [1-2个产品]
}
```
- 请求频率：10次/分钟
- 风险：低
- 适合：常规抢购，持续数小时

---

#### 3. 积极监控（加快速度）
```json
{
  "check_interval": 20,
  "target_stores": ["R448", "R479", "R645"],
  "target_products": [1个产品]
}
```
- 请求频率：9次/分钟
- 风险：低
- 适合：已知近期会补货，想快速发现

---

#### 4. 激进监控（高频抢购，有风险）
```json
{
  "check_interval": 15,
  "target_stores": ["R448", "R479"],
  "target_products": [1个产品]
}
```
- 请求频率：8次/分钟
- 风险：中低
- 适合：确定某门店即将补货，短时间冲刺

---

#### 5. 极限模式（不建议）
```json
{
  "check_interval": 10,
  "target_stores": ["R448"],
  "target_products": [1个产品]
}
```
- 请求频率：6次/分钟
- 风险：中等（可能30分钟内触发）
- 适合：紧急抢购，可接受被限制风险

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## ⚡ 瞬间抢购的特殊策略

### 问题：iPhone发售瞬间，可能几分钟内售罄

**矛盾点：**
- 需要极快的监控频率（如每5秒）
- 但会触发API限制

### 解决方案：分阶段策略

#### 阶段1：预热期（发售前1-2小时）
```json
{
  "check_interval": 60,
  "target_stores": [3个最可能的门店]
}
```
- 目的：保持IP活跃，不触发限制
- 频率：低频

---

#### 阶段2：准备期（发售前10分钟）
```json
{
  "check_interval": 30,
  "target_stores": [2个最快的门店]
}
```
- 目的：接近发售时间，加快频率
- 频率：中等

---

#### 阶段3：冲刺期（发售瞬间，0-5分钟）⚡
```json
{
  "check_interval": 8,
  "target_stores": [1个门店]
}
```
- 频率：高频（冒险）
- 预期：可能2-3分钟内触发限制
- 策略：**发现有货立即下单，然后停止监控**

**代码实现：**
```python
# 冲刺模式
if 发现有货:
    发送通知()
    播放声音()
    停止监控()  # 立即停止，去下单！
    
# 不要等到被限制，一旦有货就停
```

---

#### 阶段4：恢复期（触发限制后）
```
等待60秒后：
{
  "check_interval": 90,
  "target_stores": [1个门店]
}
```
- 降低频率，尝试恢复

---

### 多人协作策略（合法）

如果有多个人/设备：

```
设备A（家庭WiFi）：
- 监控门店：R448, R479
- 间隔：30秒

设备B（公司网络）：
- 监控门店：R645, R401
- 间隔：30秒

设备C（手机4G）：
- 监控门店：R581, R678
- 间隔：30秒
```

**优势：**
- ✅ 不同IP，互不影响
- ✅ 覆盖更多门店
- ✅ 单设备频率低，安全
- ✅ 总覆盖面更广

**注意：**
- ❌ 不要同一IP多开（会叠加）
- ✅ 每个IP独立遵守频率限制

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 🔒 进阶检测对抗

### 1. 随机化User-Agent
```python
USER_AGENTS = [
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) Safari/605.1.15',
]

headers['User-Agent'] = random.choice(USER_AGENTS)
```

### 2. 随机间隔
```python
# 当前：固定间隔
time.sleep(30)

# 改进：随机波动±10%
delay = random.uniform(27, 33)
time.sleep(delay)
```

### 3. 会话管理
```python
# 每100次请求，重建Session
if request_count % 100 == 0:
    session.close()
    session = requests.Session()
```

### 4. 错误恢复
```python
consecutive_541 = 0

if response.status_code == 541:
    consecutive_541 += 1
    
    if consecutive_541 == 1:
        sleep(10)  # 第1次：小休息
    elif consecutive_541 == 2:
        sleep(30)  # 第2次：中休息
    elif consecutive_541 >= 3:
        sleep(120)  # 第3次：长休息
        consecutive_541 = 0
else:
    consecutive_541 = 0  # 成功后重置
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 📌 核心结论

### 黄金规则
```
✅ 10次/分钟 = 100%安全（实测验证）
⚠️  15次/分钟 = 70%安全（可短期冲刺）
🔴 20次/分钟 = 30%安全（高风险）
💀 30次/分钟 = 必触发
```

### 配置建议
```
长期运行：check_interval ≥ 60秒
常规抢购：check_interval = 30秒 ⭐推荐
短期冲刺：check_interval = 15-20秒
极限模式：check_interval = 8-10秒（冒险）
```

### 门店数量
```
≤ 5个门店：安全（30秒间隔）
6-10个门店：需增加到60秒间隔
> 10个门店：需分批监控或更长间隔
```

### 多开规则
```
✅ 不同IP可并行
❌ 同一IP多开 = 自杀
```

### 瞬间抢购
```
策略：短时间高频（冒险）+ 发现立即停止
而非：长时间高频（必被限制）
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 🎯 给用户的最终建议

### 如果你要抢iPhone 17首发：

**阶段1：发售前（保持低调）**
```bash
check_interval: 60秒
门店：5个你最近的
产品：1个你最想要的
```

**阶段2：发售瞬间（冲刺5分钟）**
```bash
check_interval: 10秒
门店：1个（最可能有货的）
产品：1个

# 一旦发现有货：
1. 立即停止监控（Ctrl+C）
2. 马上去Apple官网下单
3. 不要犹豫，秒杀战只有几分钟
```

**阶段3：发售后（长期捡漏）**
```bash
check_interval: 30秒
门店：3-5个
产品：1-2个

# 可持续运行数小时甚至一整天
# 等待补货或退单
```

---

**记住：**
1. **10次/分钟是铁律**
2. **同一IP不多开**
3. **发现有货立即停止监控去下单**
4. **抢购靠速度，不是靠监控频率**

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

