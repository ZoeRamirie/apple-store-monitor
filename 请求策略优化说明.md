# 🎯 请求策略优化方案

## 📊 当前问题

### 现有逻辑（不够优化）

```python
# 当前可能的逻辑
for product in products:  # 产品1, 产品2, 产品3
    for store in stores:  # 门店1, 门店2, 门店3
        发送请求(product, store)
        sleep(1秒)

# 请求顺序：
产品1-门店1 → 产品1-门店2 → 产品1-门店3 → 
产品2-门店1 → 产品2-门店2 → 产品2-门店3 → 
产品3-门店1 → 产品3-门店2 → 产品3-门店3
```

**问题：**
- ❌ 模式太规律（容易被识别为机器人）
- ❌ 同一产品连续查询多个门店（不自然）
- ❌ 固定间隔（太规律）

---

## ✅ 优化方案：随机打散策略

### 核心思想

**将所有"产品-门店"组合打散，随机顺序逐个发送**

```python
# 优化后的逻辑
组合列表 = []
for product in products:
    for store in stores:
        组合列表.append((product, store))

# 打乱顺序
random.shuffle(组合列表)

# 逐个发送，随机间隔
for (product, store) in 组合列表:
    发送请求(product, store)
    随机延迟(3-6秒)  # 随机间隔
```

**优势：**
- ✅ 请求顺序随机（更像人类行为）
- ✅ 不会连续查询同一产品或同一门店
- ✅ 间隔时间随机（难以被识别）
- ✅ 完全打散，无规律可循

---

## 🔧 具体实现

### 1. 修改 apple_store_monitor.py

```python
import random

def check_multiple_products_optimized(self, products, stores=None):
    """
    优化的多产品监控 - 随机打散策略
    """
    if stores is None:
        stores = self.target_stores
    
    # 步骤1: 生成所有组合
    combinations = []
    for product in products:
        for store in stores:
            combinations.append({
                'product': product,
                'store': store
            })
    
    # 步骤2: 随机打乱顺序
    random.shuffle(combinations)
    
    logger.info(f"📊 本轮将检查 {len(combinations)} 个组合（已随机打散）")
    
    # 步骤3: 逐个发送请求，随机间隔
    results = []
    error_count = 0
    
    for i, combo in enumerate(combinations, 1):
        product = combo['product']
        store = combo['store']
        
        # 发送请求
        result = self.check_product_availability(
            product['part_number'],
            store
        )
        
        results.append(result)
        
        # 检测 HTTP 541
        if 'HTTP 541' in str(result.get('error', '')):
            error_count += 1
            logger.warning(f"⚠️  API限制警告 ({error_count}/3)")
            
            if error_count >= 3:
                logger.error(f"🛑 连续触发限制，停止本轮剩余 {len(combinations) - i} 个请求")
                break
        else:
            error_count = 0  # 成功后重置
        
        # 随机延迟（最后一个不延迟）
        if i < len(combinations):
            delay = self._random_delay(
                min_delay=3,
                max_delay=6,
                base_delay=4.5
            )
            logger.debug(f"⏳ 等待 {delay:.1f} 秒后发送下一个请求...")
            self._interruptible_sleep(delay)
    
    return results

def _random_delay(self, min_delay=3, max_delay=6, base_delay=4.5):
    """
    生成随机延迟时间
    
    Args:
        min_delay: 最小延迟（秒）
        max_delay: 最大延迟（秒）
        base_delay: 基准延迟（秒），用于正态分布
    
    Returns:
        随机延迟时间（秒）
    """
    # 方法1: 均匀分布（简单）
    # return random.uniform(min_delay, max_delay)
    
    # 方法2: 正态分布（更自然）
    delay = random.gauss(base_delay, 0.8)  # 均值4.5秒，标准差0.8
    
    # 限制在范围内
    delay = max(min_delay, min(max_delay, delay))
    
    return delay
```

---

### 2. 配置文件示例

#### 优化前（问题配置）

```json
{
  "target_products": [
    {"name": "iPhone 17 Pro Max 银色 256GB", "part_number": "MG034CH/A"},
    {"name": "iPhone 17 Pro Max 橙色 256GB", "part_number": "MG044CH/A"},
    {"name": "iPhone 17 Pro Max 蓝色 256GB", "part_number": "MG054CH/A"}
  ],
  "target_stores": ["R320", "R448", "R359", "R401", "R484"],
  "check_interval": 30
}
```

**分析：**
- 3产品 × 5门店 = 15个请求
- 按现有逻辑：产品1遍历5店 → 产品2遍历5店 → 产品3遍历5店
- 间隔：1秒（固定）
- 问题：模式规律，容易被识别

#### 优化后（推荐配置）

```json
{
  "target_products": [
    {"name": "iPhone 17 Pro Max 银色 256GB", "part_number": "MG034CH/A"},
    {"name": "iPhone 17 Pro Max 橙色 256GB", "part_number": "MG044CH/A"}
  ],
  "target_stores": ["R320", "R448", "R359"],
  "check_interval": 60,
  "randomize_order": true,
  "random_delay": {
    "min": 3,
    "max": 6,
    "base": 4.5
  }
}
```

**分析：**
- 2产品 × 3门店 = 6个请求
- 顺序：随机打散（每轮不同）
- 间隔：3-6秒随机
- 一轮：约30秒（6次 × 5秒平均）
- 总周期：30 + 60 = 90秒
- 频率：6次/90秒 = 4次/分钟 ✅ **极其安全！**

---

## 📊 请求顺序对比

### 优化前（规律明显）

```
第1轮:
09:00:00 - 产品1-门店1
09:00:01 - 产品1-门店2
09:00:02 - 产品1-门店3
09:00:03 - 产品2-门店1
09:00:04 - 产品2-门店2
09:00:05 - 产品2-门店3
... 等待30秒

第2轮:
09:00:36 - 产品1-门店1  ← 完全重复第1轮顺序
09:00:37 - 产品1-门店2
...
```

**问题：** 太规律！容易被识别为机器人

---

### 优化后（随机打散）

```
第1轮:
09:00:00 - 产品2-门店3 (随机延迟5.2秒)
09:00:05 - 产品1-门店1 (随机延迟3.8秒)
09:00:09 - 产品2-门店1 (随机延迟4.6秒)
09:00:14 - 产品1-门店3 (随机延迟5.5秒)
09:00:19 - 产品1-门店2 (随机延迟4.1秒)
09:00:23 - 产品2-门店2
... 等待60秒

第2轮:
09:01:24 - 产品1-门店2 (随机延迟4.8秒) ← 顺序完全不同！
09:01:29 - 产品2-门店1 (随机延迟3.5秒)
09:01:33 - 产品1-门店3 (随机延迟5.9秒)
09:01:39 - 产品2-门店3 (随机延迟4.2秒)
09:01:43 - 产品1-门店1 (随机延迟5.1秒)
09:01:48 - 产品2-门店2
... 等待60秒
```

**优势：**
- ✅ 每轮顺序不同
- ✅ 间隔时间不固定
- ✅ 完全随机，无规律
- ✅ 更像人类行为

---

## 🎯 不同规模的最佳配置

### 小规模监控（2产品 × 3门店）

```json
{
  "target_products": [2个],
  "target_stores": [3个],
  "check_interval": 60,
  "random_delay": {"min": 3, "max": 6}
}
```

- 6个组合，随机顺序
- 间隔：3-6秒
- 一轮：约30秒
- 频率：4次/分钟 ✅

---

### 中规模监控（3产品 × 4门店）

```json
{
  "target_products": [3个],
  "target_stores": [4个],
  "check_interval": 90,
  "random_delay": {"min": 4, "max": 7}
}
```

- 12个组合，随机顺序
- 间隔：4-7秒
- 一轮：约66秒
- 频率：7.7次/分钟 ✅

---

### 大规模监控（4产品 × 5门店）

```json
{
  "target_products": [4个],
  "target_stores": [5个],
  "check_interval": 150,
  "random_delay": {"min": 5, "max": 8}
}
```

- 20个组合，随机顺序
- 间隔：5-8秒
- 一轮：约130秒
- 频率：9.2次/分钟 ✅

---

## 🛡️ 额外防护措施

### 1. 每轮重新打散

```python
# 每轮检查时都重新打乱顺序
def monitor_loop(self):
    while not self.stop_event.is_set():
        # 每轮都重新生成并打乱组合
        combinations = self._generate_combinations()
        random.shuffle(combinations)  # 每轮顺序不同
        
        for combo in combinations:
            ...
```

### 2. 随机 User-Agent

```python
USER_AGENTS = [
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) Safari/605.1.15',
]

# 每个请求随机选择
headers['User-Agent'] = random.choice(USER_AGENTS)
```

### 3. 动态调整间隔

```python
# 根据时间段调整间隔
current_hour = datetime.now().hour

if 9 <= current_hour <= 11:  # 上班高峰
    delay = random.uniform(6, 10)  # 更长间隔
elif 20 <= current_hour <= 22:  # 晚上高峰
    delay = random.uniform(6, 10)
else:  # 其他时段
    delay = random.uniform(4, 6)
```

---

## 📋 实现步骤

### 步骤1: 修改监控类

在 `apple_store_monitor.py` 中：

```python
def check_multiple_products(self, products, stores=None):
    """
    优化版本：随机打散策略
    """
    # 1. 生成所有组合
    combinations = []
    for product in products:
        for store in (stores or self.target_stores):
            combinations.append((product, store))
    
    # 2. 随机打乱
    random.shuffle(combinations)
    
    # 3. 逐个请求，随机间隔
    results = []
    for i, (product, store) in enumerate(combinations):
        result = self.check_product_availability(
            product['part_number'], 
            store
        )
        results.append(result)
        
        # 随机延迟
        if i < len(combinations) - 1:
            delay = random.uniform(3, 6)
            self._interruptible_sleep(delay)
    
    return results
```

### 步骤2: 更新配置

```json
{
  "randomize_order": true,
  "random_delay": {
    "enabled": true,
    "min": 3,
    "max": 6
  }
}
```

### 步骤3: 测试验证

```bash
# 运行监控，观察日志
python3 main.py

# 日志应显示：
📊 本轮检查 6 个组合（已随机打散）
⏳ 等待 4.8 秒后发送下一个请求...
⏳ 等待 5.2 秒后发送下一个请求...
⏳ 等待 3.9 秒后发送下一个请求...
```

---

## 🎊 总结

### 核心改进

1. **打散组合** - 将产品×门店的所有组合打散
2. **随机顺序** - 每轮都重新打乱顺序
3. **随机间隔** - 3-6秒随机延迟
4. **无规律** - 完全随机，难以被识别

### 优势

- ✅ 更像人类行为
- ✅ 降低被检测风险
- ✅ 请求更分散
- ✅ 更安全稳定

### 配置建议

| 规模 | 产品×门店 | check_interval | 间隔范围 | 频率 |
|------|-----------|----------------|----------|------|
| 小 | 2×3=6 | 60秒 | 3-6秒 | 4次/分 ✅ |
| 中 | 3×4=12 | 90秒 | 4-7秒 | 7.7次/分 ✅ |
| 大 | 4×5=20 | 150秒 | 5-8秒 | 9.2次/分 ✅ |

---

**这个策略是目前最安全、最智能的方案！** ✅


